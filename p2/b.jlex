import java_cup.runtime.*; // defines the Symbol class

// The generated scanner will return a Symbol for each token that it finds.
// A Symbol contains an Object field named value; that field will be of type
// TokenVal, defined below.
//
// A TokenVal object contains the line number on which the token occurs as
// well as the number of the character on that line that starts the token.
// Some tokens (literals and IDs) also include the value of the token.
class TokenVal {
  // fields
    int linenum;
    int charnum;
  // constructor
    TokenVal(int lnum, int cnum) {
        linenum = lnum;
        charnum = cnum;
    }
}

class IntLitTokenVal extends TokenVal {
  // new field: the value of the integer literal
    int intVal;
  // constructor
    IntLitTokenVal(int lnum, int cnum, int val) {
        super(lnum, cnum);
        intVal = val;
    }
}

class IdTokenVal extends TokenVal {
  // new field: the value of the identifier
    String idVal;
  // constructor
    IdTokenVal(int lnum, int cnum, String val) {
        super(lnum, cnum);
    idVal = val;
    }
}

class StrLitTokenVal extends TokenVal {
  // new field: the value of the string literal
    String strVal;
  // constructor
    StrLitTokenVal(int lnum, int cnum, String val) {
        super(lnum, cnum);
        strVal = val;
    }
}

// The following class is used to keep track of the character number at which
// the current token starts on its line.
class CharNum {
    static int num=1;
}
%%

DIGIT=        [0-9]
LETTER=       [a-zA-Z]
WHITESPACE=   [\040\t]
CHAR=         [a-zA-Z{DIGIT}]*

IDENTIFIER=   ({LETTER}|_)(_|{LETTER}|{DIGIT})*

IntLit=       [0-9]+

StrChar=      (\\n|\\t|\\"|\\'|\?|\\\|{CHAR}|{WHITESPACE})
StrLit=       "\"({StrChar})*\""

Comment=    {TraditionalComment}|{EndOfLineComment}|{DocumentationComment}

TraditionalComment = "/*" [^*] ~"*/" | "/*" "*"+ "/"
EndOfLineComment = "//" {InputCharacter}* {LineTerminator}?
DocumentationComment = "/*" "*"+ [^/*] ~"*/"

%implements java_cup.runtime.Scanner
%function next_token
%type java_cup.runtime.Symbol

%eofval{
return new Symbol(sym.EOF);
%eofval}

%line

%%
"bool"    {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.BOOL, tokenVal);
          }
"int"     {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.INT, tokenVal);
          }
"void"    {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.VOID, tokenVal);
          }
"tru"     {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.TRUE, tokenVal);
          }
"fls"     {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.FALSE, tokenVal);
          }
"struct"  {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.STRUCT, tokenVal);
          }
"receive" {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.RECEIVE, tokenVal);
          }
"print"   {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.PRINT, tokenVal);
          }
"if"      {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.IF, tokenVal);
          }
"else"    {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.ELSE, tokenVal);
          }
"while"   {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.WHILE, tokenVal);
          }
"ret"     {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += yytext().length();
            return new Symbol(sym.RETURN, tokenVal);
          }
{DIGIT}+  { // NOTE: the following computation of the integer value does NOT
            //       check for overflow.  This must be changed.
            try {
                int val = (new Integer(yytext())).intValue();

                Symbol S = new Symbol(sym.INTLITERAL,
                                 new IntLitTokenVal(yyline+1, CharNum.num, val));
                CharNum.num += yytext().length();
                return S;
            } catch (NumberFormatException e) {
                ErrMsg.warn(yyline + 1,
                            CharNum.num,
                            "integer literal too large; using max value");
                IntLitTokenVal tokenVal = new IntLitTokenVal(yyline + 1,
                                                             CharNum.num,
                                                             Integer.MAX_VALUE);
                CharNum.num += yytext().length();
                return new Symbol(sym.INTLITERAL, tokenVal);
            }
          }


{IDENTIFIER} {
                IdTokenVal tokenVal = new IdTokenVal(yyline + 1,
                                                     CharNum.num,
                                                     yytext());
                CharNum.num += yytext().length();
                return new Symbol(sym.ID, tokenVal);
              }
	       
{StrLit}  {
            StrLitTokenVal token = new StrLitTokenVal(yyline +1,
                                                      CharNum.num,
                                                      yytext());
            CharNum.num += yytext().length();
            return new Symbol(sym.STRINGLITERAL, token);
          }

\n        { CharNum.num = 1; }

{WHITESPACE}+  { CharNum.num += yytext().length(); }

"+"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.PLUS, tokenVal);
          }

"-"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.MINUS, tokenVal);
          }
"*"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.TIMES, tokenVal);
          }
"/"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.DIVIDE, tokenVal);
          }
"="       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.ASSIGN, tokenVal);
          }
"<"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.LESS, tokenVal);
          }
">"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.GREATER, tokenVal);
          }
"!"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.NOT, tokenVal);
          }
"{"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.LCURLY, tokenVal);
          }
"}"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.RCURLY, tokenVal);
          }
"("       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.LPAREN, tokenVal);
          }
")"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.RPAREN, tokenVal);
          }
";"       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.SEMICOLON, tokenVal);
          }
","       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.COMMA, tokenVal);
          }
"."       {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num++);
            return new Symbol(sym.DOT, tokenVal);
          }
"<<"      {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.RECEIVE, tokenVal);
          }
">>"      {
            TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.PRINT, tokenVal);
          }
"++"      { TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.PLUSPLUS, tokenVal);
          }
"--"      { TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.MINUSMINUS, tokenVal);
          }
"&&"      { TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.AND, tokenVal);
          }
"||"      { TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.OR, tokenVal);
          }
"=="      { TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.EQUALS, tokenVal);
          }
"!="      { TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.NOTEQUALS, tokenVal);
          }
"<="      { TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.LESSEQ, tokenVal);
          }
">="      { TokenVal tokenVal = new TokenVal(yyline + 1, CharNum.num);
            CharNum.num += 2;
            return new Symbol(sym.GREATEREQ, tokenVal);
          }

.         { ErrMsg.fatal(yyline+1, CharNum.num,
                         "illegal character ignored: " + yytext());
            CharNum.num++;
          }